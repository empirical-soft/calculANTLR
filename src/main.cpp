#include <iostream>
#include <string>

// generated by ANTLR
#include <antlr4-runtime.h>
#include <CalculantlrLexer.h>
#include <CalculantlrParser.h>
#include <CalculantlrBaseVisitor.h>

// generated by ASDL
#include <AST.h>

// ANTLR-generated namespaces
using namespace calculantlr;
using namespace antlr4;

// parse visitor inherits from ANTLR-generated base class
class ParseVisitor : public CalculantlrBaseVisitor {
 public:

  antlrcpp::Any visitOpExpr(CalculantlrParser::OpExprContext *ctx) override {
    // recursively visit the left and right expressions
    AST::expr_t left = visit(ctx->left);
    AST::expr_t right = visit(ctx->right);

    // translate the operator
    AST::operator_t op;
    char op_char = ctx->op->getText()[0];
    switch (op_char) {
      case '+':
        op = AST::operator_t::kAdd;
        break;
      case '-':
        op = AST::operator_t::kSub;
        break;
      case '*':
        op = AST::operator_t::kMult;
        break;
      case '/':
        op = AST::operator_t::kDiv;
        break;
    }

    // package everything together for the AST
    return AST::BinOp(left, op, right);
  }

  antlrcpp::Any visitAtomExpr(CalculantlrParser::AtomExprContext *ctx) override {
    // parse numerical string and store as an AST literal
    return AST::IntLit(std::stoi(ctx->getText()));
  }

  antlrcpp::Any visitParenExpr(CalculantlrParser::ParenExprContext *ctx) override {
    // parenthesis means just visit the contents
    return visit(ctx->expr());
  }
};

// eval visitor inherits from ASDL-generated base class
class EvalVisitor : public AST::BaseVisitor {
 public:

  antlrcpp::Any visitBinOp(AST::BinOp_t node) override {
    // recursively evaluate the left and right expressions
    int left_value = visit(node->left);
    int right_value = visit(node->right);

    // compute in C++
    int result;
    switch (node->op) {
      case AST::operator_t::kAdd:
        result = left_value + right_value;
        break;
      case AST::operator_t::kSub:
        result = left_value - right_value;
        break;
      case AST::operator_t::kMult:
        result = left_value * right_value;
        break;
      case AST::operator_t::kDiv:
        result = left_value / right_value;
        break;
    }

    // return the compute result
    return result;
  }

  antlrcpp::Any visitIntLit(AST::IntLit_t node) override {
    // return the number
    return node->n;
  }

  antlrcpp::Any visitOperator(AST::operator_t value) override {
    // won't be invoked
    return 0;
  }
};

// evaluate a string by parsing it and traversing resulting AST
int eval(const std::string& line) {
  // build parse tree
  ANTLRInputStream input(line);
  CalculantlrLexer lexer(&input);
  CommonTokenStream tokens(&lexer);
  CalculantlrParser parser(&tokens);
  tree::ParseTree* parse_tree = parser.expr();

  // print parse tree
  //std::cout << parse_tree->toStringTree(&parser) << std::endl;

  // build abstract syntax tree
  ParseVisitor parse_visitor;
  AST::expr_t ast = parse_visitor.visit(parse_tree);

  // print abstract syntax tree
  //std::cout << AST::to_string(ast) << std::endl;

  // return integer evaluation of AST
  EvalVisitor eval_visitor;
  return eval_visitor.visit(ast);
}

// REPL driver; invoke with rlwrap for up-arrow goodness
int main() {
  std::string line;
  std::cout << ">>> ";
  while (std::getline(std::cin, line)) {
    std::cout << eval(line) << std::endl;
    std::cout << ">>> ";
  }
  return 0;
}

